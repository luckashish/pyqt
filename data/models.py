"""Data models for the trading application."""
from dataclasses import dataclass, field
from datetime import datetime
from typing import Optional
from enum import Enum


class OrderType(Enum):
    """Order type enumeration."""
    BUY = "buy"
    SELL = "sell"
    BUY_LIMIT = "buy limit"
    SELL_LIMIT = "sell limit"
    BUY_STOP = "buy stop"
    SELL_STOP = "sell stop"


class OrderStatus(Enum):
    """Order status enumeration."""
    PENDING = "pending"
    ACTIVE = "active"
    FILLED = "filled"
    CLOSED = "closed"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class OHLCData:
    """OHLC (Open, High, Low, Close) candlestick data."""
    timestamp: datetime
    open: float
    high: float
    low: float
    close: float
    volume: float = 0.0
    
    def __post_init__(self):
        """Validate OHLC data."""
        if self.high < max(self.open, self.close, self.low):
            self.high = max(self.open, self.close, self.low)
        if self.low > min(self.open, self.close, self.high):
            self.low = min(self.open, self.close, self.high)


@dataclass
class Symbol:
    """Trading symbol information."""
    name: str
    bid: float = 0.0
    ask: float = 0.0
    last: float = 0.0
    open: float = 0.0
    high: float = 0.0
    low: float = 0.0
    close: float = 0.0
    volume: float = 0.0
    description: str = ""
    display_name: str = ""  # Alternate format (e.g., MCX:NATURALGAS vs MCX|467741)
    last_tick_time: datetime = field(default_factory=datetime.now)
    
    @property
    def spread(self) -> float:
        """Calculate spread in pips (assuming 4-digit quote)."""
        return round((self.ask - self.bid) * 10000, 1)
    
    @property
    def trend(self) -> str:
        """Simple trend indicator based on bid/ask."""
        # This is placeholder logic - in real app would use historical data
        return "up" if self.bid > self.ask - self.spread / 10000 else "down"


@dataclass
class Order:
    """Trading order."""
    ticket: int
    symbol: str
    order_type: OrderType
    volume: float  # lot size
    open_price: float
    open_time: datetime
    sl: float = 0.0  # stop loss
    tp: float = 0.0  # take profit
    status: OrderStatus = OrderStatus.ACTIVE
    close_price: Optional[float] = None
    close_time: Optional[datetime] = None
    comment: str = ""
    rejection_reason: str = ""
    
    def calculate_profit(self, current_price: float, pip_value: float = 10.0) -> float:
        """
        Calculate current profit/loss.
        pip_value: value of 1 pip in account currency (default $10 for standard lot)
        """
        if self.status == OrderStatus.CLOSED and self.close_price:
            price_diff = self.close_price - self.open_price
        else:
            price_diff = current_price - self.open_price
        
        # Invert for sell orders
        if self.order_type in [OrderType.SELL, OrderType.SELL_LIMIT, OrderType.SELL_STOP]:
            price_diff = -price_diff
        
        # Convert to pips and multiply by volume
        pips = price_diff * 10000  # Assuming 4-digit quote
        profit = pips * pip_value * self.volume
        
        return round(profit, 2)
    
    @property
    def is_buy(self) -> bool:
        """Check if order is a buy order."""
        return self.order_type in [OrderType.BUY, OrderType.BUY_LIMIT, OrderType.BUY_STOP]
    
    @property
    def duration(self) -> str:
        """Get order duration as string."""
        if self.close_time:
            delta = self.close_time - self.open_time
        else:
            delta = datetime.now() - self.open_time
        
        hours = delta.seconds // 3600
        minutes = (delta.seconds % 3600) // 60
        return f"{delta.days}d {hours}h {minutes}m"


@dataclass
class Position:
    """Simplified position model (aggregated orders)."""
    symbol: str
    volume: float
    entry_price: float
    current_price: float
    profit: float
    is_long: bool


@dataclass
class NewsItem:
    """Market news item."""
    headline: str
    source: str
    timestamp: datetime
    impact: str  # "high", "medium", "low"
    content: str = ""
    currency: str = ""


@dataclass
class CalendarEvent:
    """Economic calendar event."""
    date: datetime
    currency: str
    event: str
    impact: str  # "high", "medium", "low"
    forecast: str = ""
    previous: str = ""
    actual: str = ""


@dataclass
class Alert:
    """Price alert."""
    symbol: str
    condition: str  # "above", "below"
    price: float
    enabled: bool = True
    triggered: bool = False
    created_time: datetime = field(default_factory=datetime.now)
    notification_type: str = "both"  # "visual", "audio", "both"
    last_price: float = 0.0  # Track last price to detect crossover
    triggered_time: Optional[datetime] = None


@dataclass
class EASignal:
    """Trading signal generated by Expert Advisor."""
    ea_name: str
    symbol: str
    signal_type: str  # "BUY", "SELL", "CLOSE_BUY", "CLOSE_SELL"
    timestamp: datetime
    price: float
    stop_loss: float = 0.0
    take_profit: float = 0.0
    reason: str = ""  # Why signal was generated
    confidence: float = 1.0  # 0-1 signal strength
    volume: float = 0.1  # Lot size


@dataclass
class EAState:
    """Expert Advisor runtime state."""
    name: str
    enabled: bool = False
    status: str = "stopped"  # "running", "stopped", "paused", "error"
    symbol: str = ""
    timeframe: str = ""
    open_positions: int = 0
    total_trades: int = 0
    winning_trades: int = 0
    profit: float = 0.0  # Realized profit from closed trades
    floating_profit: float = 0.0  # Unrealized profit from open positions
    last_signal: Optional['EASignal'] = None
    error_message: str = ""
    started_time: Optional[datetime] = None
    last_update: datetime = field(default_factory=datetime.now)
    
    @property
    def win_rate(self) -> float:
        """Calculate win rate percentage."""
        if self.total_trades == 0:
            return 0.0
        return round((self.winning_trades / self.total_trades) * 100, 2)
    
    @property
    def total_profit(self) -> float:
        """Calculate total profit (realized + unrealized)."""
        return self.profit + self.floating_profit


@dataclass
class EAConfig:
    """Expert Advisor configuration."""
    name: str
    enabled: bool = False
    symbol: str = "NSE|26000"
    timeframe: str = "M5"
    
    # Strategy parameters (stored as dict for flexibility)
    parameters: dict = field(default_factory=dict)
    
    # Risk management
    lot_size: float = 0.1
    risk_percent: float = 2.0
    use_dynamic_sizing: bool = False
    stop_loss_pips: float = 50.0
    take_profit_pips: float = 100.0
    use_trailing_stop: bool = False
    trailing_stop_pips: float = 30.0
    max_concurrent_positions: int = 1
    
    # Filters
    enable_time_filter: bool = False
    trading_start_hour: int = 9
    trading_end_hour: int = 15
    max_spread_pips: float = 3.0
    
    # Limits
    max_daily_loss: float = 5.0  # percent
    max_risk_per_trade: float = 2.0  # percent
